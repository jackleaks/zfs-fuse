diff -ur zfs-fuse-0.5.0/src/SConstruct zfs-fuse-0.5.0_slash/src/SConstruct
--- zfs-fuse-0.5.0/src/SConstruct	2008-09-12 21:37:59.000000000 -0400
+++ zfs-fuse-0.5.0_slash/src/SConstruct	2008-10-02 13:22:18.559655436 -0400
@@ -14,6 +14,7 @@
 env['CCFLAGS'] = Split('-pipe -Wall -Werror -std=c99 -Wno-switch -Wno-unused -Wno-missing-braces -Wno-parentheses -Wno-uninitialized -fno-strict-aliasing -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_REENTRANT -DTEXT_DOMAIN=\\"zfs-fuse\\" -DLINUX_AIO')
 
 debug = int(ARGUMENTS.get('debug', '1'))
+slashlib = int(ARGUMENTS.get('slashlib', '0'))
 
 if not debug:
 	env.Append(LINKFLAGS = ['-s'])
@@ -28,6 +29,13 @@
 	elif debug == 3:
 		env.Append(CCFLAGS = Split('-finstrument-functions -DDEBUG'))
 
+if slashlib:
+	print "enabling slashlib target\n";
+	env.Append(CCFLAGS = ['-DSLASHLIB'])	
+	env['SLASHLIB'] = '1'		
+else:
+	env['SLASHLIB'] = '0'			
+
 env['CPPPATH'] = []
 
 f = os.popen('uname -m')
diff -ur zfs-fuse-0.5.0/src/zfs-fuse/main.c zfs-fuse-0.5.0_slash/src/zfs-fuse/main.c
--- zfs-fuse-0.5.0/src/zfs-fuse/main.c	2008-09-12 21:37:59.000000000 -0400
+++ zfs-fuse-0.5.0_slash/src/zfs-fuse/main.c	2008-10-02 13:16:56.194814708 -0400
@@ -115,6 +115,7 @@
 	}
 }
 
+#ifndef SLASHLIB
 int main(int argc, char *argv[])
 {
 	parse_args(argc, argv);
@@ -123,11 +124,15 @@
 		do_daemon(cf_pidfile);
 	}
 
+#else
+int zfs_lib_start(void)
+{
+#endif
 	if(do_init() != 0) {
 		do_exit();
 		return 1;
 	}
-
+	
 	if(set_signal_handler(SIGHUP, exit_handler) != 0 ||
 	   set_signal_handler(SIGINT, exit_handler) != 0 ||
 	   set_signal_handler(SIGTERM, exit_handler) != 0 ||
diff -ur zfs-fuse-0.5.0/src/zfs-fuse/SConscript zfs-fuse-0.5.0_slash/src/zfs-fuse/SConscript
--- zfs-fuse-0.5.0/src/zfs-fuse/SConscript	2008-09-12 21:37:59.000000000 -0400
+++ zfs-fuse-0.5.0_slash/src/zfs-fuse/SConscript	2008-10-30 19:19:18.977439681 -0400
@@ -1,9 +1,18 @@
 Import('env')
 
-objects = Split('main.c cmd_listener.c ptrace.c util.c zfs_acl.c zfs_dir.c zfs_ioctl.c zfs_log.c zfs_replay.c zfs_rlock.c zfs_vfsops.c zfs_vnops.c zvol.c fuse_listener.c zfsfuse_socket.c zfs_operations.c #lib/libzpool/libzpool-kernel.a #lib/libzfscommon/libzfscommon-kernel.a #lib/libnvpair/libnvpair-kernel.a #lib/libavl/libavl.a #lib/libumem/libumem.a #lib/libsolkerncompat/libsolkerncompat.a')
+if (env['SLASHLIB']) == "1":
+	print "slashlib enabled %s\n"  % (env['SLASHLIB'])
+else:
+	print "slashlib disabled %s\n" % (env['SLASHLIB'])
+
+objects = Split('main.c cmd_listener.c ptrace.c util.c zfs_acl.c zfs_dir.c zfs_ioctl.c zfs_log.c zfs_replay.c zfs_rlock.c zfs_vfsops.c zfs_vnops.c zvol.c fuse_listener.c zfsfuse_socket.c zfs_operations_slash.c #lib/libzpool/libzpool-kernel.a #lib/libzfscommon/libzfscommon-kernel.a #lib/libnvpair/libnvpair-kernel.a #lib/libavl/libavl.a #lib/libumem/libumem.a #lib/libsolkerncompat/libsolkerncompat.a')
 cpppath = Split('#lib/libavl/include #lib/libnvpair/include #lib/libumem/include #lib/libzfscommon/include #lib/libsolkerncompat/include')
 ccflags = Split('-D_KERNEL')
 
 libs = Split('rt pthread fuse dl z aio')
 
-env.Program('zfs-fuse', objects, CPPPATH = env['CPPPATH'] + cpppath, LIBS = libs, CCFLAGS = env['CCFLAGS'] + ccflags)
+if (env['SLASHLIB']) == "1":
+	env.StaticLibrary('libzfs-fuse', objects, CPPPATH = env['CPPPATH'] + cpppath, LIBS = libs, CCFLAGS = env['CCFLAGS'] + ccflags)
+else:
+	env.Program('zfs-fuse', objects, CPPPATH = env['CPPPATH'] + cpppath, LIBS = libs, CCFLAGS = env['CCFLAGS'] + ccflags)
+
diff -ur zfs-fuse-0.5.0/src/zfs-fuse/zfs_operations_slash.c zfs-fuse-0.5.0_slash/src/zfs-fuse/zfs_operations_slash.c
--- zfs-fuse-0.5.0/src/zfs-fuse/zfs_operations_slash.c	2008-10-02 14:42:21.221472031 -0400
+++ zfs-fuse-0.5.0_slash/src/zfs-fuse/zfs_operations_slash.c	2008-10-30 19:46:37.299922797 -0400
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#include "fuse.h"
-
 #include <sys/statfs.h>
 #include <sys/statvfs.h>
 #include <sys/debug.h>
@@ -42,22 +40,79 @@
 #include <time.h>
 
 #include "util.h"
-#include "fuse_listener.h"
 
 #define ZFS_MAGIC 0x2f52f5
 
-static void zfsfuse_getcred(fuse_req_t req, cred_t *cred)
+typedef unsigned long long int u64;
+typedef unsigned long long int __u64;
+typedef unsigned int __u32;
+
+struct fidgen {
+        u64 fid;
+        u64 gen;
+};
+
+typedef struct file_info {
+	vnode_t *vp;
+	int flags;
+} file_info_t;
+
+kmem_cache_t *file_info_cache = NULL;
+
+/* 'to_set' flags in setattr */
+#define FUSE_SET_ATTR_MODE	(1 << 0)
+#define FUSE_SET_ATTR_UID	(1 << 1)
+#define FUSE_SET_ATTR_GID	(1 << 2)
+#define FUSE_SET_ATTR_SIZE	(1 << 3)
+#define FUSE_SET_ATTR_ATIME	(1 << 4)
+#define FUSE_SET_ATTR_MTIME	(1 << 5)
+
+struct fuse_dirent {
+	__u64	ino;
+	__u64	off;
+	__u32	namelen;
+	__u32	type;
+	char name[0];
+};
+
+#define FUSE_NAME_OFFSET ((unsigned) ((struct fuse_dirent *) 0)->name)
+#define FUSE_DIRENT_ALIGN(x) (((x) + sizeof(__u64) - 1) & ~(sizeof(__u64) - 1))
+#define FUSE_DIRENT_SIZE(d) \
+	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)
+
+
+size_t fuse_dirent_size(size_t namelen)
 {
-	const struct fuse_ctx *ctx = fuse_req_ctx(req);
+    return FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + namelen);
+}
 
-	cred->cr_uid = ctx->uid;
-	cred->cr_gid = ctx->gid;
+char *fuse_add_dirent(char *buf, const char *name, const struct stat *stbuf,
+                      off_t off)
+{
+    unsigned namelen = strlen(name);
+    unsigned entlen = FUSE_NAME_OFFSET + namelen;
+    unsigned entsize = fuse_dirent_size(namelen);
+    unsigned padlen = entsize - entlen;
+    struct fuse_dirent *dirent = (struct fuse_dirent *) buf;
+
+    dirent->ino = stbuf->st_ino;
+    dirent->off = off;
+    dirent->namelen = namelen;
+    dirent->type = (stbuf->st_mode & 0170000) >> 12;
+    strncpy(dirent->name, name, namelen);
+    if (padlen)
+        memset(buf + entlen, 0, padlen);
+
+    return buf + entsize;
 }
 
-static void zfsfuse_destroy(void *userdata)
+
+#define ZFS_MAGIC 0x2f52f5
+
+static void zfsslash2_destroy(void *userdata)
 {
 	vfs_t *vfs = (vfs_t *) userdata;
-
+	
 	struct timespec req;
 	req.tv_sec = 0;
 	req.tv_nsec = 100000000; /* 100 ms */
@@ -70,46 +125,42 @@
 	 * and we're terminating the process. Therefore we need to
 	 * force unmount since there could still be opened files
 	 */
-	while(do_umount(vfs, exit_fuse_listener) != 0)
+	while(do_umount(vfs, 0) != 0)
 		nanosleep(&req, NULL);
 #ifdef DEBUG
 	fprintf(stderr, "do_umount() done\n");
 #endif
 }
 
-static void zfsfuse_statfs(fuse_req_t req)
+static int zfsslash2_statfs(void *vfsdata, struct statvfs *stat)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *)vfsdata;
 
 	struct statvfs64 zfs_stat;
 
 	int ret = VFS_STATVFS(vfs, &zfs_stat);
-	if(ret != 0) {
-		fuse_reply_err(req, ret);
-		return;
-	}
-
-	struct statvfs stat = { 0 };
+	if(ret != 0)
+		return (ret);
 
 	/* There's a bug somewhere in FUSE, in the kernel or in df(1) where
 	   f_bsize is being used to calculate filesystem size instead of
 	   f_frsize, so we must use that instead */
-	stat.f_bsize = zfs_stat.f_frsize;
-	stat.f_frsize = zfs_stat.f_frsize;
-	stat.f_blocks = zfs_stat.f_blocks;
-	stat.f_bfree = zfs_stat.f_bfree;
-	stat.f_bavail = zfs_stat.f_bavail;
-	stat.f_files = zfs_stat.f_files;
-	stat.f_ffree = zfs_stat.f_ffree;
-	stat.f_favail = zfs_stat.f_favail;
-	stat.f_fsid = zfs_stat.f_fsid;
-	stat.f_flag = zfs_stat.f_flag;
-	stat.f_namemax = zfs_stat.f_namemax;
+	stat->f_bsize = zfs_stat.f_frsize;
+	stat->f_frsize = zfs_stat.f_frsize;
+	stat->f_blocks = zfs_stat.f_blocks;
+	stat->f_bfree = zfs_stat.f_bfree;
+	stat->f_bavail = zfs_stat.f_bavail;
+	stat->f_files = zfs_stat.f_files;
+	stat->f_ffree = zfs_stat.f_ffree;
+	stat->f_favail = zfs_stat.f_favail;
+	stat->f_fsid = zfs_stat.f_fsid;
+	stat->f_flag = zfs_stat.f_flag;
+	stat->f_namemax = zfs_stat.f_namemax;
 
-	fuse_reply_statfs(req, &stat);
+	return (0);
 }
 
-static int zfsfuse_stat(vnode_t *vp, struct stat *stbuf, cred_t *cred)
+static int zfsslash2_stat(vnode_t *vp, struct stat *stbuf, cred_t *cred)
 {
 	ASSERT(vp != NULL);
 	ASSERT(stbuf != NULL);
@@ -140,16 +191,17 @@
 	return 0;
 }
 
-static int zfsfuse_getattr(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
+static int zfsslash2_getattr(void *vfsdata, u64 ino, cred_t *cred, struct stat *stbuf)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *)vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	u64 real_ino = ino == 1 ? 3 : ino;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
-	int error = zfs_zget(zfsvfs, ino, &znode, B_TRUE);
+	int error = zfs_zget(zfsvfs, real_ino, &znode, B_TRUE);
 	if(error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
@@ -161,38 +213,24 @@
 	vnode_t *vp = ZTOV(znode);
 	ASSERT(vp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	struct stat stbuf;
-	error = zfsfuse_stat(vp, &stbuf, &cred);
+	error = zfsslash2_stat(vp, stbuf, cred);
 
 	VN_RELE(vp);
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_attr(req, &stbuf, 0.0);
-
 	return error;
 }
 
-static void zfsfuse_getattr_helper(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_getattr(req, real_ino, fi);
-	if(error)
-		fuse_reply_err(req, error);
-}
-
-static int zfsfuse_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)
+static int zfsslash2_lookup(void *vfsdata, u64 parent, const char *name, cred_t *cred, struct stat *stb)
 {
 	if(strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *)vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
+	if (parent == 1) parent = 3;
+	
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -211,55 +249,40 @@
 
 	vnode_t *vp = NULL;
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	error = VOP_LOOKUP(dvp, (char *) name, &vp, NULL, 0, NULL, &cred, NULL, NULL, NULL);
+	error = VOP_LOOKUP(dvp, (char *) name, &vp, NULL, 0, NULL, cred, NULL, NULL, NULL);
 	if(error)
 		goto out;
 
-	struct fuse_entry_param e = { 0 };
-
-	e.attr_timeout = 0.0;
-	e.entry_timeout = 0.0;
-
 	if(vp == NULL)
 		goto out;
+	
+	u64 ino, gen;
 
-	e.ino = VTOZ(vp)->z_id;
-	if(e.ino == 3)
-		e.ino = 1;
-
-	e.generation = VTOZ(vp)->z_phys->zp_gen;
-
-	error = zfsfuse_stat(vp, &e.attr, &cred);
-
+	ino = VTOZ(vp)->z_id;
+	if(ino == 3)
+		ino = 1;
+	
+	VTOZ(vp)->z_phys->zp_gen;
+	
+	error = zfsslash2_stat(vp, stb, cred);
 out:
 	if(vp != NULL)
 		VN_RELE(vp);
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_entry(req, &e);
-
 	return error;
-}
-
-static void zfsfuse_lookup_helper(fuse_req_t req, fuse_ino_t parent, const char *name)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
-
-	int error = zfsfuse_lookup(req, real_parent, name);
-	if(error)
-		fuse_reply_err(req, error);
-}
+ }
 
-static int zfsfuse_opendir(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
+/* XXX replace fuse_file_info with something meaningful for slash d_ino cache
+ */
+static int zfsslash2_opendir(void *vfsdata, u64 ino, cred_t *cred, struct fidgen *fg, void **private)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
+	if (ino == 1) ino = 3;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -280,24 +303,21 @@
 		error = ENOTDIR;
 		goto out;
 	}
-
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
 	/*
 	 * Check permissions.
 	 */
-	if (error = VOP_ACCESS(vp, VREAD | VEXEC, 0, &cred, NULL))
+	if (error = VOP_ACCESS(vp, VREAD | VEXEC, 0, cred, NULL))
 		goto out;
 
 	vnode_t *old_vp = vp;
 
 	/* XXX: not sure about flags */
-	error = VOP_OPEN(&vp, FREAD, &cred, NULL);
+	error = VOP_OPEN(&vp, FREAD, cred, NULL);
 
 	ASSERT(old_vp == vp);
 
 	if(!error) {
+		/* XXX convert to the slash d_ino cache */
 		file_info_t *info = kmem_cache_alloc(file_info_cache, KM_NOSLEEP);
 		if(info == NULL) {
 			error = ENOMEM;
@@ -307,7 +327,13 @@
 		info->vp = vp;
 		info->flags = FREAD;
 
-		fi->fh = (uint64_t) (uintptr_t) info;
+		*private = info;
+		
+		fg->fid = VTOZ(vp)->z_id;
+		if(fg->fid == 3)
+			fg->fid = 1;
+		
+		fg->gen = VTOZ(vp)->z_phys->zp_gen;
 	}
 
 out:
@@ -315,37 +341,26 @@
 		VN_RELE(vp);
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_open(req, fi);
-
 	return error;
 }
 
-static void zfsfuse_opendir_helper(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_opendir(req, real_ino, fi);
-	if(error)
-		fuse_reply_err(req, error);
-}
-
-static int zfsfuse_release(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
+/*  XXX convert to the slash d_ino cache .. same as above
+ */
+static int zfsslash2_release(void *vfsdata, u64 ino, cred_t *cred, void *data)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	file_info_t *info = (file_info_t *)data;
 
+	if (ino == 1) ino = 3;
+	       
 	ZFS_ENTER(zfsvfs);
 
-	file_info_t *info = (file_info_t *)(uintptr_t) fi->fh;
 	ASSERT(info->vp != NULL);
 	ASSERT(VTOZ(info->vp) != NULL);
 	ASSERT(VTOZ(info->vp)->z_id == ino);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	int error = VOP_CLOSE(info->vp, info->flags, 1, (offset_t) 0, &cred, NULL);
+	int error = VOP_CLOSE(info->vp, info->flags, 1, (offset_t) 0, cred, NULL);
 	VERIFY(error == 0);
 
 	VN_RELE(info->vp);
@@ -357,18 +372,15 @@
 	return error;
 }
 
-static void zfsfuse_release_helper(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
 
-	int error = zfsfuse_release(req, real_ino, fi);
-	/* Release events always reply_err */
-	fuse_reply_err(req, error);
-}
+/* XXX caller will have to free outbuf */
+static int zfsslash2_readdir(void *vfsdata, u64 ino, cred_t *cred, size_t size, off_t off, 
+			     char *outbuf, size_t *outbuf_len, void *data)
+{	
+	vnode_t *vp = ((file_info_t *)(uintptr_t) data)->vp;
+
+	if (ino == 1) ino = 3;
 
-static int zfsfuse_readdir(fuse_req_t req, fuse_ino_t ino, size_t size, off_t off, struct fuse_file_info *fi)
-{
-	vnode_t *vp = ((file_info_t *)(uintptr_t) fi->fh)->vp;
 	ASSERT(vp != NULL);
 	ASSERT(VTOZ(vp) != NULL);
 	ASSERT(VTOZ(vp)->z_id == ino);
@@ -376,18 +388,14 @@
 	if(vp->v_type != VDIR)
 		return ENOTDIR;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
-	char *outbuf = kmem_alloc(size, KM_NOSLEEP);
 	if(outbuf == NULL)
-		return ENOMEM;
+		return EINVAL;
 
 	ZFS_ENTER(zfsvfs);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
 	union {
 		char buf[DIRENT64_RECLEN(MAXNAMELEN)];
 		struct dirent64 dirent;
@@ -418,7 +426,7 @@
 		uio.uio_resid = iovec.iov_len;
 		uio.uio_loffset = next;
 
-		error = VOP_READDIR(vp, &uio, &cred, &eofp, NULL, 0);
+		error = VOP_READDIR(vp, &uio, cred, &eofp, NULL, 0);
 		if(error)
 			goto out;
 
@@ -442,37 +450,28 @@
 
 out:
 	ZFS_EXIT(zfsvfs);
-
-	if(!error)
-		fuse_reply_buf(req, outbuf, outbuf_off);
-
-	kmem_free(outbuf, size);
+	/* XXX caller does free..
+	 */
+	*outbuf_len = outbuf_off;
 
 	return error;
 }
 
-static void zfsfuse_readdir_helper(fuse_req_t req, fuse_ino_t ino, size_t size, off_t off, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_readdir(req, real_ino, size, off, fi);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_opencreate(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi, int fflags, mode_t createmode, const char *name)
+static int 
+zfsslash2_opencreate(void *vfsdata, u64 ino, cred_t *cred, int fflags, 
+		     mode_t createmode, const char *name, struct fidgen *fg, 
+		     struct stat *stb, void **private)
 {
 	if(name && strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	u64 real_ino = ino == 1 ? 3 : ino;
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
 	/* Map flags */
 	int mode, flags;
 
@@ -508,7 +507,7 @@
 
 	znode_t *znode;
 
-	int error = zfs_zget(zfsvfs, ino, &znode, B_FALSE);
+	int error = zfs_zget(zfsvfs, real_ino, &znode, B_FALSE);
 	if(error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
@@ -531,7 +530,7 @@
 		vattr.va_mode = createmode;
 		vattr.va_mask = AT_TYPE|AT_MODE;
 		if (flags & FTRUNC) {
-			vattr.va_size = 0;
+			vattr.va_size = 0; //XXX fixme, don't wipe out the metadata at the beginning
 			vattr.va_mask |= AT_SIZE;
 		}
 		if (flags & FEXCL)
@@ -541,7 +540,7 @@
 
 		vnode_t *new_vp;
 		/* FIXME: check filesystem boundaries */
-		error = VOP_CREATE(vp, (char *) name, &vattr, excl, mode, &new_vp, &cred, 0, NULL, NULL);
+		error = VOP_CREATE(vp, (char *) name, &vattr, excl, mode, &new_vp, cred, 0, NULL, NULL);
 
 		if(error)
 			goto out;
@@ -557,7 +556,7 @@
 		if (!(flags & FOFFMAX) && (vp->v_type == VREG)) {
 			vattr_t vattr;
 			vattr.va_mask = AT_SIZE;
-			if ((error = VOP_GETATTR(vp, &vattr, 0, &cred, NULL)))
+			if ((error = VOP_GETATTR(vp, &vattr, 0, cred, NULL)))
 				goto out;
 
 			if (vattr.va_size > (u_offset_t) MAXOFF32_T) {
@@ -573,7 +572,7 @@
 		/*
 		 * Check permissions.
 		 */
-		if (error = VOP_ACCESS(vp, mode, 0, &cred, NULL))
+		if (error = VOP_ACCESS(vp, mode, 0, cred, NULL))
 			goto out;
 	}
 
@@ -584,21 +583,18 @@
 
 	vnode_t *old_vp = vp;
 
-	error = VOP_OPEN(&vp, flags, &cred, NULL);
+	error = VOP_OPEN(&vp, flags, cred, NULL);
 
 	ASSERT(old_vp == vp);
 
 	if(error)
 		goto out;
 
-	struct fuse_entry_param e = { 0 };
-
-	if(flags & FCREAT) {
-		error = zfsfuse_stat(vp, &e.attr, &cred);
-		if(error)
-			goto out;
-	}
-
+	//if(flags & FCREAT) {
+	error = zfsslash2_stat(vp, stb, cred);
+	if(error)
+		goto out;
+	//}
 	file_info_t *info = kmem_cache_alloc(file_info_cache, KM_NOSLEEP);
 	if(info == NULL) {
 		error = ENOMEM;
@@ -608,16 +604,14 @@
 	info->vp = vp;
 	info->flags = flags;
 
-	fi->fh = (uint64_t) (uintptr_t) info;
-	fi->keep_cache = 1;
+	*private = info;
 
 	if(flags & FCREAT) {
-		e.attr_timeout = 0.0;
-		e.entry_timeout = 0.0;
-		e.ino = VTOZ(vp)->z_id;
-		if(e.ino == 3)
-			e.ino = 1;
-		e.generation = VTOZ(vp)->z_phys->zp_gen;
+		fg->fid = VTOZ(vp)->z_id;
+		if(fg->fid == 3)
+			fg->fid = 1;
+
+		fg->gen = VTOZ(vp)->z_phys->zp_gen;
 	}
 
 out:
@@ -628,43 +622,22 @@
 
 	ZFS_EXIT(zfsvfs);
 
-	if(!error) {
-		if(!(flags & FCREAT))
-			fuse_reply_open(req, fi);
-		else
-			fuse_reply_create(req, &e, fi);
-	}
-	return error;
-}
-
-static void zfsfuse_open_helper(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_opencreate(req, real_ino, fi, fi->flags, 0, NULL);
-	if(error)
-		fuse_reply_err(req, error);
+	return error; 
 }
 
-static void zfsfuse_create_helper(fuse_req_t req, fuse_ino_t parent, const char *name, mode_t mode, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
 
-	int error = zfsfuse_opencreate(req, real_parent, fi, fi->flags | O_CREAT, mode, name);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_readlink(fuse_req_t req, fuse_ino_t ino)
+static int zfsslash2_readlink(void *vfsdata, u64 ino, char *buf, cred_t *cred)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	u64 real_ino = ino == 1 ? 3 : ino;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
-	int error = zfs_zget(zfsvfs, ino, &znode, B_FALSE);
+	int error = zfs_zget(zfsvfs, real_ino, &znode, B_FALSE);
 	if(error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
@@ -676,8 +649,6 @@
 	vnode_t *vp = ZTOV(znode);
 	ASSERT(vp != NULL);
 
-	char buffer[PATH_MAX + 1];
-
 	iovec_t iovec;
 	uio_t uio;
 	uio.uio_iov = &iovec;
@@ -685,47 +656,36 @@
 	uio.uio_segflg = UIO_SYSSPACE;
 	uio.uio_fmode = 0;
 	uio.uio_llimit = RLIM64_INFINITY;
-	iovec.iov_base = buffer;
-	iovec.iov_len = sizeof(buffer) - 1;
+	iovec.iov_base = buf;
+	iovec.iov_len = sizeof(buf) - 1;
 	uio.uio_resid = iovec.iov_len;
 	uio.uio_loffset = 0;
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	error = VOP_READLINK(vp, &uio, &cred, NULL);
+	error = VOP_READLINK(vp, &uio, cred, NULL);
 
 	VN_RELE(vp);
 	ZFS_EXIT(zfsvfs);
 
 	if(!error) {
-		VERIFY(uio.uio_loffset < sizeof(buffer));
-		buffer[uio.uio_loffset] = '\0';
-		fuse_reply_readlink(req, buffer);
+		VERIFY(uio.uio_loffset < sizeof(buf));
+		buf[uio.uio_loffset] = '\0';
 	}
 
 	return error;
 }
 
-static void zfsfuse_readlink_helper(fuse_req_t req, fuse_ino_t ino)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_readlink(req, real_ino);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_read(fuse_req_t req, fuse_ino_t ino, size_t size, off_t off, struct fuse_file_info *fi)
+static int zfsslash2_read(void *vfsdata, u64 ino, cred_t *cred, char *buf, size_t size, off_t off, void *data)
 {
-	file_info_t *info = (file_info_t *)(uintptr_t) fi->fh;
-
+	file_info_t *info = (file_info_t *)(uintptr_t) data;
+	u64 real_ino = ino == 1 ? 3 : ino;
 	vnode_t *vp = info->vp;
+
 	ASSERT(vp != NULL);
 	ASSERT(VTOZ(vp) != NULL);
-	ASSERT(VTOZ(vp)->z_id == ino);
+	ASSERT(VTOZ(vp)->z_id == real_ino);
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	char *outbuf = kmem_alloc(size, KM_NOSLEEP);
@@ -747,43 +707,32 @@
 	uio.uio_resid = iovec.iov_len;
 	uio.uio_loffset = off;
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	int error = VOP_READ(vp, &uio, info->flags, &cred, NULL);
+	int error = VOP_READ(vp, &uio, info->flags, cred, NULL);
 
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_buf(req, outbuf, uio.uio_loffset - off);
-
-	kmem_free(outbuf, size);
+	//if(!error)
+		//	fuse_reply_buf(req, outbuf, uio.uio_loffset - off);
 
 	return error;
 }
 
-static void zfsfuse_read_helper(fuse_req_t req, fuse_ino_t ino, size_t size, off_t off, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_read(req, real_ino, size, off, fi);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name, mode_t mode)
+static int zfsslash2_mkdir(void *vfsdata, u64 parent, const char *name, mode_t mode, 
+			   cred_t *cred, struct stat *stb, struct fidgen *fg)
 {
 	if(strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	u64 real_parent = real_parent == 1 ? 3 : parent;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
-	int error = zfs_zget(zfsvfs, parent, &znode, B_FALSE);
+	int error = zfs_zget(zfsvfs, real_parent, &znode, B_FALSE);
 	if(error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
@@ -802,27 +751,19 @@
 	vattr.va_mode = mode & PERMMASK;
 	vattr.va_mask = AT_TYPE | AT_MODE;
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	error = VOP_MKDIR(dvp, (char *) name, &vattr, &vp, &cred, NULL, 0, NULL);
+	error = VOP_MKDIR(dvp, (char *) name, &vattr, &vp, cred, NULL, 0, NULL);
 	if(error)
 		goto out;
 
 	ASSERT(vp != NULL);
 
-	struct fuse_entry_param e = { 0 };
+	fg->fid = VTOZ(vp)->z_id;
+	if(fg->fid == 3)
+		fg->fid = 1;
 
-	e.attr_timeout = 0.0;
-	e.entry_timeout = 0.0;
+	fg->gen = VTOZ(vp)->z_phys->zp_gen;
 
-	e.ino = VTOZ(vp)->z_id;
-	if(e.ino == 3)
-		e.ino = 1;
-
-	e.generation = VTOZ(vp)->z_phys->zp_gen;
-
-	error = zfsfuse_stat(vp, &e.attr, &cred);
+	error = zfsslash2_stat(vp, stb, cred);
 
 out:
 	if(vp != NULL)
@@ -830,34 +771,24 @@
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_entry(req, &e);
-
 	return error;
 }
 
-static void zfsfuse_mkdir_helper(fuse_req_t req, fuse_ino_t parent, const char *name, mode_t mode)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
-
-	int error = zfsfuse_mkdir(req, real_parent, name, mode);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)
+static int zfsslash2_rmdir(void *vfsdata, u64 parent, const char *name, cred_t *cred)
 {
 	if(strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	u64 real_parent = real_parent == 1 ? 3 : parent;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
-	int error = zfs_zget(zfsvfs, parent, &znode, B_FALSE);
+	int error = zfs_zget(zfsvfs, real_parent, &znode, B_FALSE);
 	if(error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
@@ -869,12 +800,9 @@
 	vnode_t *dvp = ZTOV(znode);
 	ASSERT(dvp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
 	/* FUSE doesn't care if we remove the current working directory
 	   so we just pass NULL as the cwd parameter (no problem for ZFS) */
-	error = VOP_RMDIR(dvp, (char *) name, NULL, &cred, NULL, 0);
+	error = VOP_RMDIR(dvp, (char *) name, NULL, cred, NULL, 0);
 
 	/* Linux uses ENOTEMPTY when trying to remove a non-empty directory */
 	if(error == EEXIST)
@@ -886,34 +814,26 @@
 	return error;
 }
 
-static void zfsfuse_rmdir_helper(fuse_req_t req, fuse_ino_t parent, const char *name)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
 
-	int error = zfsfuse_rmdir(req, real_parent, name);
-	/* rmdir events always reply_err */
-	fuse_reply_err(req, error);
-}
-
-static int zfsfuse_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr, int to_set, struct fuse_file_info *fi)
+static int zfsslash2_setattr(void *vfsdata, u64 ino, struct stat *attr, int to_set, cred_t *cred, struct stat *out_attr, void *data)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	u64 real_ino = real_ino == 1 ? 3 : ino;
+	file_info_t *info = (file_info_t *)data;
 
 	ZFS_ENTER(zfsvfs);
 
 	vnode_t *vp;
 	boolean_t release;
+	
 
 	int error;
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	if(fi == NULL) {
+	if (!info) {
 		znode_t *znode;
 
-		error = zfs_zget(zfsvfs, ino, &znode, B_TRUE);
+		error = zfs_zget(zfsvfs, real_ino, &znode, B_TRUE);
 		if(error) {
 			ZFS_EXIT(zfsvfs);
 			/* If the inode we are trying to get was recently deleted
@@ -924,7 +844,6 @@
 		vp = ZTOV(znode);
 		release = B_TRUE;
 	} else {
-		file_info_t *info = (file_info_t *)(uintptr_t) fi->fh;
 		vp = info->vp;
 		release = B_FALSE;
 
@@ -955,7 +874,7 @@
 			bf.l_len = (off_t) 0;
 
 			/* FIXME: check locks */
-			error = VOP_SPACE(vp, F_FREESP, &bf, info->flags, 0, &cred, NULL);
+			error = VOP_SPACE(vp, F_FREESP, &bf, info->flags, 0, cred, NULL);
 			if(error)
 				goto out;
 
@@ -995,13 +914,13 @@
 	}
 
 	int flags = (to_set & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) ? ATTR_UTIME : 0;
-	error = VOP_SETATTR(vp, &vattr, flags, &cred, NULL);
+	error = VOP_SETATTR(vp, &vattr, flags, cred, NULL);
 
 out: ;
 	struct stat stat_reply;
 
 	if(!error)
-		error = zfsfuse_stat(vp, &stat_reply, &cred);
+		error = zfsslash2_stat(vp, out_attr, cred);
 
 	/* Do not release if vp was an opened inode */
 	if(release)
@@ -1009,34 +928,24 @@
 
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_attr(req, &stat_reply, 0.0);
-
 	return error;
 }
 
-static void zfsfuse_setattr_helper(fuse_req_t req, fuse_ino_t ino, struct stat *attr, int to_set, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
 
-	int error = zfsfuse_setattr(req, real_ino, attr, to_set, fi);
-	if(error)
-		fuse_reply_err(req, error);
-}
-
-static int zfsfuse_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)
+static int zfsslash2_unlink(void *vfsdata, u64 parent, const char *name, cred_t *cred)
 {
+	vfs_t *vfs = (vfs_t *) vfsdata;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	u64 real_parent = real_parent == 1 ? 3 : parent;
+
 	if(strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
-	zfsvfs_t *zfsvfs = vfs->vfs_data;
-
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
-	int error = zfs_zget(zfsvfs, parent, &znode, B_FALSE);
+	int error = zfs_zget(zfsvfs, real_parent, &znode, B_FALSE);
 	if(error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
@@ -1048,10 +957,7 @@
 	vnode_t *dvp = ZTOV(znode);
 	ASSERT(dvp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	error = VOP_REMOVE(dvp, (char *) name, &cred, NULL, 0);
+	error = VOP_REMOVE(dvp, (char *) name, cred, NULL, 0);
 
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
@@ -1059,25 +965,18 @@
 	return error;
 }
 
-static void zfsfuse_unlink_helper(fuse_req_t req, fuse_ino_t parent, const char *name)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
-
-	int error = zfsfuse_unlink(req, real_parent, name);
-	/* unlink events always reply_err */
-	fuse_reply_err(req, error);
-}
 
-static int zfsfuse_write(fuse_req_t req, fuse_ino_t ino, const char *buf, size_t size, off_t off, struct fuse_file_info *fi)
+static int zfsslash2_write(void *vfsdata, u64 ino, cred_t *cred, const char *buf, size_t size, off_t off, void *data)
 {
-	file_info_t *info = (file_info_t *)(uintptr_t) fi->fh;
+	file_info_t *info = (file_info_t *)(uintptr_t) data;
+	u64 real_ino = ino == 1 ? 3 : ino;
 
 	vnode_t *vp = info->vp;
 	ASSERT(vp != NULL);
 	ASSERT(VTOZ(vp) != NULL);
-	ASSERT(VTOZ(vp)->z_id == ino);
+	ASSERT(VTOZ(vp)->z_id == real_ino);
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
@@ -1095,37 +994,26 @@
 	uio.uio_resid = iovec.iov_len;
 	uio.uio_loffset = off;
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	int error = VOP_WRITE(vp, &uio, info->flags, &cred, NULL);
+	int error = VOP_WRITE(vp, &uio, info->flags, cred, NULL);
 
 	ZFS_EXIT(zfsvfs);
 
 	if(!error) {
 		/* When not using direct_io, we must always write 'size' bytes */
 		VERIFY(uio.uio_resid == 0);
-		fuse_reply_write(req, size - uio.uio_resid);
 	}
 
 	return error;
 }
 
-static void zfsfuse_write_helper(fuse_req_t req, fuse_ino_t ino, const char *buf, size_t size, off_t off, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_write(req, real_ino, buf, size, off, fi);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_mknod(fuse_req_t req, fuse_ino_t parent, const char *name, mode_t mode, dev_t rdev)
+#if 0
+static int zfsslash2_mknod(void *vfsdata, u64 parent, const char *name, mode_t mode, dev_t rdev)
 {
 	if(strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
@@ -1144,9 +1032,6 @@
 	vnode_t *dvp = ZTOV(znode);
 	ASSERT(dvp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
 	vattr_t vattr;
 	vattr.va_type = IFTOVT(mode);
 	vattr.va_mode = mode & PERMMASK;
@@ -1180,7 +1065,7 @@
 
 	e.generation = VTOZ(vp)->z_phys->zp_gen;
 
-	error = zfsfuse_stat(vp, &e.attr, &cred);
+	error = zfsslash2_stat(vp, &e.attr, &cred);
 
 out:
 	if(vp != NULL)
@@ -1192,29 +1077,23 @@
 
 	return error;
 }
+#endif
 
-static void zfsfuse_mknod_helper(fuse_req_t req, fuse_ino_t parent, const char *name, mode_t mode, dev_t rdev)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
 
-	int error = zfsfuse_mknod(req, real_parent, name, mode, rdev);
-	if(error)
-		fuse_reply_err(req, error);
-}
-
-static int zfsfuse_symlink(fuse_req_t req, const char *link, fuse_ino_t parent, const char *name)
+static int zfsslash2_symlink(void *vfsdata, const char *link, u64 parent, const char *name, cred_t *cred, struct stat *stb, struct fidgen *fg)
 {
 	if(strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
+	u64 real_parent = parent == 1 ? 3 : parent;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
-	int error = zfs_zget(zfsvfs, parent, &znode, B_FALSE);
+	int error = zfs_zget(zfsvfs, real_parent, &znode, B_FALSE);
 	if(error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
@@ -1226,39 +1105,31 @@
 	vnode_t *dvp = ZTOV(znode);
 	ASSERT(dvp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
 	vattr_t vattr;
 	vattr.va_type = VLNK;
 	vattr.va_mode = 0777;
 	vattr.va_mask = AT_TYPE | AT_MODE;
 
-	error = VOP_SYMLINK(dvp, (char *) name, &vattr, (char *) link, &cred, NULL, 0);
+	error = VOP_SYMLINK(dvp, (char *) name, &vattr, (char *) link, cred, NULL, 0);
 
 	vnode_t *vp = NULL;
 
 	if(error)
 		goto out;
 
-	error = VOP_LOOKUP(dvp, (char *) name, &vp, NULL, 0, NULL, &cred, NULL, NULL, NULL);
+	error = VOP_LOOKUP(dvp, (char *) name, &vp, NULL, 0, NULL, cred, NULL, NULL, NULL);
 	if(error)
 		goto out;
 
 	ASSERT(vp != NULL);
 
-	struct fuse_entry_param e = { 0 };
-
-	e.attr_timeout = 0.0;
-	e.entry_timeout = 0.0;
-
-	e.ino = VTOZ(vp)->z_id;
-	if(e.ino == 3)
-		e.ino = 1;
+	fg->fid = VTOZ(vp)->z_id;
+	if(fg->fid == 3)
+		fg->fid = 1;
 
-	e.generation = VTOZ(vp)->z_phys->zp_gen;
+	fg->gen = VTOZ(vp)->z_phys->zp_gen;
 
-	error = zfsfuse_stat(vp, &e.attr, &cred);
+	error = zfsslash2_stat(vp, stb, cred);
 
 out:
 	if(vp != NULL)
@@ -1267,31 +1138,22 @@
 
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_entry(req, &e);
-
 	return error;
 }
 
-static void zfsfuse_symlink_helper(fuse_req_t req, const char *link, fuse_ino_t parent, const char *name)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
-
-	int error = zfsfuse_symlink(req, link, real_parent, name);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_rename(fuse_req_t req, fuse_ino_t parent, const char *name, fuse_ino_t newparent, const char *newname)
+static int zfsslash2_rename(void *vfsdata, u64 parent, const char *name, u64 newparent, const char *newname, cred_t *cred)
 {
 	if(strlen(name) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 	if(strlen(newname) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
+	if (parent == 1) parent = 3;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *p_znode, *np_znode;
@@ -1322,10 +1184,7 @@
 	ASSERT(p_vp != NULL);
 	ASSERT(np_vp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	error = VOP_RENAME(p_vp, (char *) name, np_vp, (char *) newname, &cred, NULL, 0);
+	error = VOP_RENAME(p_vp, (char *) name, np_vp, (char *) newname, cred, NULL, 0);
 
 	VN_RELE(p_vp);
 	VN_RELE(np_vp);
@@ -1335,59 +1194,42 @@
 	return error;
 }
 
-static void zfsfuse_rename_helper(fuse_req_t req, fuse_ino_t parent, const char *name, fuse_ino_t newparent, const char *newname)
-{
-	fuse_ino_t real_parent = parent == 1 ? 3 : parent;
-	fuse_ino_t real_newparent = newparent == 1 ? 3 : newparent;
-
-	int error = zfsfuse_rename(req, real_parent, name, real_newparent, newname);
-
-	/* rename events always reply_err */
-	fuse_reply_err(req, error);
-}
-
-static int zfsfuse_fsync(fuse_req_t req, fuse_ino_t ino, int datasync, struct fuse_file_info *fi)
+static int zfsslash2_fsync(void *vfsdata, u64 ino, cred_t *cred, int datasync, void *data)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
+	if (ino == 1) ino = 3;
+
 	ZFS_ENTER(zfsvfs);
 
-	file_info_t *info = (file_info_t *)(uintptr_t) fi->fh;
+	file_info_t *info = (file_info_t *)(uintptr_t) data;
 	ASSERT(info->vp != NULL);
 	ASSERT(VTOZ(info->vp) != NULL);
 	ASSERT(VTOZ(info->vp)->z_id == ino);
 
 	vnode_t *vp = info->vp;
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	int error = VOP_FSYNC(vp, datasync ? FDSYNC : FSYNC, &cred, NULL);
+	int error = VOP_FSYNC(vp, datasync ? FDSYNC : FSYNC, cred, NULL);
 
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
-static void zfsfuse_fsync_helper(fuse_req_t req, fuse_ino_t ino, int datasync, struct fuse_file_info *fi)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_fsync(req, real_ino, datasync, fi);
 
-	/* fsync events always reply_err */
-	fuse_reply_err(req, error);
-}
-
-static int zfsfuse_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent, const char *newname)
+static int zfsslash2_link(void *vfsdata, u64 ino, u64 newparent, const char *newname, 
+			  struct fidgen *fg, cred_t *cred, struct stat *stb)
 {
 	if(strlen(newname) >= MAXNAMELEN)
 		return ENAMETOOLONG;
 
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
+	if (newparent == 1) newparent = 3;
+	if (ino == 1) ino = 3;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *td_znode, *s_znode;
@@ -1416,34 +1258,26 @@
 	ASSERT(svp != NULL);
 	ASSERT(tdvp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
-
-	error = VOP_LINK(tdvp, svp, (char *) newname, &cred, NULL, 0);
+	error = VOP_LINK(tdvp, svp, (char *) newname, cred, NULL, 0);
 
 	vnode_t *vp = NULL;
 
 	if(error)
 		goto out;
 
-	error = VOP_LOOKUP(tdvp, (char *) newname, &vp, NULL, 0, NULL, &cred, NULL, NULL, NULL);
+	error = VOP_LOOKUP(tdvp, (char *) newname, &vp, NULL, 0, NULL, cred, NULL, NULL, NULL);
 	if(error)
 		goto out;
 
 	ASSERT(vp != NULL);
 
-	struct fuse_entry_param e = { 0 };
-
-	e.attr_timeout = 0.0;
-	e.entry_timeout = 0.0;
-
-	e.ino = VTOZ(vp)->z_id;
-	if(e.ino == 3)
-		e.ino = 1;
+	fg->fid = VTOZ(vp)->z_id;
+	if(fg->fid == 3)
+		fg->fid = 1;
 
-	e.generation = VTOZ(vp)->z_phys->zp_gen;
+	fg->gen = VTOZ(vp)->z_phys->zp_gen;
 
-	error = zfsfuse_stat(vp, &e.attr, &cred);
+	error = zfsslash2_stat(vp, stb, cred);
 
 out:
 	if(vp != NULL)
@@ -1453,27 +1287,17 @@
 
 	ZFS_EXIT(zfsvfs);
 
-	if(!error)
-		fuse_reply_entry(req, &e);
-
 	return error;
-}
+ }
 
-static void zfsfuse_link_helper(fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent, const char *newname)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-	fuse_ino_t real_newparent = newparent == 1 ? 3 : newparent;
-
-	int error = zfsfuse_link(req, real_ino, real_newparent, newname);
-	if(error)
-		fuse_reply_err(req, error);
-}
 
-static int zfsfuse_access(fuse_req_t req, fuse_ino_t ino, int mask)
+static int zfsslash2_access(void *vfsdata, u64 ino, int mask, cred_t *cred)
 {
-	vfs_t *vfs = (vfs_t *) fuse_req_userdata(req);
+	vfs_t *vfs = (vfs_t *) vfsdata;
 	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
+	if (ino == 1) ino = 3;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -1490,8 +1314,6 @@
 	vnode_t *vp = ZTOV(znode);
 	ASSERT(vp != NULL);
 
-	cred_t cred;
-	zfsfuse_getcred(req, &cred);
 
 	int mode = 0;
 	if(mask & R_OK)
@@ -1501,7 +1323,7 @@
 	if(mask & X_OK)
 		mode |= VEXEC;
 
-	error = VOP_ACCESS(vp, mode, 0, &cred, NULL);
+	error = VOP_ACCESS(vp, mode, 0, cred, NULL);
 
 	VN_RELE(vp);
 
@@ -1510,40 +1332,3 @@
 	return error;
 }
 
-static void zfsfuse_access_helper(fuse_req_t req, fuse_ino_t ino, int mask)
-{
-	fuse_ino_t real_ino = ino == 1 ? 3 : ino;
-
-	int error = zfsfuse_access(req, real_ino, mask);
-
-	/* access events always reply_err */
-	fuse_reply_err(req, error);
-}
-
-struct fuse_lowlevel_ops zfs_operations =
-{
-	.open       = zfsfuse_open_helper,
-	.read       = zfsfuse_read_helper,
-	.write      = zfsfuse_write_helper,
-	.release    = zfsfuse_release_helper,
-	.opendir    = zfsfuse_opendir_helper,
-	.readdir    = zfsfuse_readdir_helper,
-	.releasedir = zfsfuse_release_helper,
-	.lookup     = zfsfuse_lookup_helper,
-	.getattr    = zfsfuse_getattr_helper,
-	.readlink   = zfsfuse_readlink_helper,
-	.mkdir      = zfsfuse_mkdir_helper,
-	.rmdir      = zfsfuse_rmdir_helper,
-	.create     = zfsfuse_create_helper,
-	.unlink     = zfsfuse_unlink_helper,
-	.mknod      = zfsfuse_mknod_helper,
-	.symlink    = zfsfuse_symlink_helper,
-	.link       = zfsfuse_link_helper,
-	.rename     = zfsfuse_rename_helper,
-	.setattr    = zfsfuse_setattr_helper,
-	.fsync      = zfsfuse_fsync_helper,
-	.fsyncdir   = zfsfuse_fsync_helper,
-	.access     = zfsfuse_access_helper,
-	.statfs     = zfsfuse_statfs,
-	.destroy    = zfsfuse_destroy,
-};
